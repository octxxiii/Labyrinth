# 아키텍처 문서

## 개요
Labyrinth는 Clean Architecture 패턴을 따르는 Flutter 애플리케이션입니다. 이 아키텍처는 코드의 유지보수성, 테스트 용이성, 그리고 확장성을 보장합니다.

## 아키텍처 계층

### 1. Presentation Layer (UI)
- **화면 표시 및 사용자 입력 처리**
  - Flutter 위젯을 사용한 UI 구현
  - 사용자 인터랙션 처리
  - 화면 전환 및 네비게이션 관리

- **BLoC 패턴을 사용한 상태 관리**
  - UI 상태 관리
  - 비즈니스 로직과 UI의 분리
  - 이벤트 기반 상태 업데이트

### 2. Domain Layer (비즈니스 로직)
- **Use Cases**
  - 단일 책임 원칙에 따른 비즈니스 로직 캡슐화
  - 재사용 가능한 독립적인 기능 단위
  - 트랜잭션 관리

- **Entities**
  - 비즈니스 규칙을 포함하는 핵심 객체
  - 데이터베이스나 외부 서비스에 독립적
  - 순수한 Dart 클래스로 구현

- **Repository Interfaces**
  - 데이터 접근 계약 정의
  - 구현 세부사항으로부터 추상화
  - 의존성 역전 원칙 준수

### 3. Data Layer (데이터 처리)
- **Repository Implementations**
  - Repository 인터페이스의 구체적 구현
  - 데이터 소스 통합
  - 데이터 변환 및 매핑

- **Data Sources**
  - 로컬 데이터베이스 (SQLite)
  - 원격 API 통신
  - 캐시 관리

- **DTOs (Data Transfer Objects)**
  - API 응답 데이터 구조화
  - 데이터 변환 및 검증
  - JSON 직렬화/역직렬화

## 주요 컴포넌트

### BLoC (Business Logic Component)
- **상태 관리**
  - 상태 정의 및 초기화
  - 상태 변경 이벤트 처리
  - 상태 스트림 관리

- **비즈니스 로직 처리**
  - Use Case 호출
  - 에러 처리
  - 비동기 작업 관리

- **UI와 비즈니스 로직 분리**
  - 관심사 분리
  - 테스트 용이성
  - 코드 재사용성

### Repository
- **데이터 접근 추상화**
  - 데이터 소스 추상화
  - 캐시 전략 구현
  - 에러 처리

- **데이터 소스 관리**
  - 데이터베이스 연결 관리
  - API 통신 관리
  - 캐시 정책 구현

### Use Cases
- **단일 책임 원칙**
  - 명확한 책임 정의
  - 독립적인 기능 구현
  - 테스트 용이성

- **재사용 가능한 기능 단위**
  - 모듈화된 비즈니스 로직
  - 조합 가능한 기능
  - 확장 가능한 구조

## 의존성 규칙

### 계층 간 의존성
- 안쪽 계층은 바깥쪽 계층을 모르지 않음
- 의존성은 안쪽으로 향함
- 계층 간 통신은 인터페이스를 통해 이루어짐

### 의존성 주입
- 생성자 주입
- 인터페이스 기반 주입
- 테스트 용이성 확보

### 모듈화
- 기능별 모듈 분리
- 공통 모듈 관리
- 확장 가능한 구조

## 디렉토리 구조
```
lib/
├── presentation/          # UI 관련 코드
│   ├── bloc/            # BLoC 관련 코드
│   ├── pages/           # 화면 위젯
│   └── widgets/         # 재사용 가능한 위젯
├── domain/              # 비즈니스 로직
│   ├── entities/        # 도메인 엔티티
│   ├── repositories/    # 리포지토리 인터페이스
│   └── usecases/       # 유스케이스
└── data/               # 데이터 처리
    ├── models/         # DTO 모델
    ├── repositories/   # 리포지토리 구현
    └── datasources/    # 데이터 소스
``` 